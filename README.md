# 整理不易，您的Fork、Star 就是我的动力

> 题库非常全面包含了 Java基础、容器、多线程、JVM、并发编程、MySQL、Redis、MongoDB、Spring、SpringBoot、Mybatis、SpringCloud、Dubbo、Zookeeper、Kafka、Nginx、MQ、网络、数据结构与算法、Linux等等

👉 **Java面试题完整版附答案，高清PDF下载：[Java面试整理高清PDF下载](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/index.md)**

👉 **Java面试题完整版附答案，高清PDF下载：[Java面试整理高清PDF下载](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/index.md)**

👉 **Java面试题完整版附答案，高清PDF下载：[Java面试整理高清PDF下载](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/index.md)**


# 面试题索引

|   |   |    |    |     |
| ------------ | ------------ | ------------ | ------------ | ------------ |
|  [Java基础](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/base/Java%E5%9F%BA%E7%A1%80.md) |  [Java集合&容器](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/base/Java%E9%9B%86%E5%90%88&%E5%AE%B9%E5%99%A8.md)   |  [JVM](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/base/JVM.md)   |  [Java并发编程](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/base/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.md)   |  [字符串&&集合](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/base/%E5%AD%97%E7%AC%A6%E4%B8%B2&%E9%9B%86%E5%90%88.md)    |
|  [网络协议](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/base/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.md) |  [数据结构与算法](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/base/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.md)   |  [MySQL](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/database/MySQL.md)   |  [Redis](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/database/Redis.md)   |  [MongoDB](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/database/MongoDB.md)    |
|  [1000行SQL命令](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/database/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4.md) |  [52条SQL语句性能优化策略](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/database/52%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5.md)   |  [Linux常用命令](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/linux/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.md)   |  [Linux面试题](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/linux/Linux%E9%9D%A2%E8%AF%95%E9%A2%98%20.md)   |  [Dubbo](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/middleware/Dubbo.md)    |
|  [ElasticSearch](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/middleware/ElasticSearch.md) |  [Kafka](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/middleware/Kafka.md)   |  [Nginx](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/middleware/Nginx.md)   |  [MQ](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/middleware/RabbitMQ.md)   |  [Zookeeper](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/middleware/zookeeper.md)    |
|  [Spring](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/%E6%A1%86%E6%9E%B6/Spring.md) |  [SpringBoot](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/%E6%A1%86%E6%9E%B6/SpringBoot.md)   |  [SpringCloud](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/%E6%A1%86%E6%9E%B6/SpringCloud.md)   |  [Spring常用注解](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/%E6%A1%86%E6%9E%B6/SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3.md)   |  [MyBatis](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/%E6%A1%86%E6%9E%B6/MyBatis.md)    |
|  [Git常用命令](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/other/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.md) |  |   |  []()   |  []()    |


# Java基础概念

### 1. Java的特点有哪些
Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点，下面针对这些特点进行逐一介绍。

**1. 面向对象**

Java 是一种面向对象的语言，它对对象中的类、对象、继承、封装、多态、接口、包等均有很好的支持。为了简单起见，Java 只支持类之间的单继承，但是可以使用接口来实现多继承。使用 Java 语言开发程序，需要采用面向对象的思想设计程序和编写代码。

**2. 平台无关性**

平台无关性的具体表现在于，Java 是“一次编写，到处运行（Write Once，Run any Where）”的语言，因此采用 Java 语言编写的程序具有很好的可移植性，而保证这一点的正是 Java 的虚拟机机制。在引入虚拟机之后，Java 语言在不同的平台上运行不需要重新编译。

Java 语言使用 Java 虚拟机机制屏蔽了具体平台的相关信息，使得 Java 语言编译的程序只需生成虚拟机上的目标代码，就可以在多种平台上不加修改地运行。

**3. 简单性**

Java 语言的语法与 C 语言和 C++ 语言很相近，使得很多程序员学起来很容易。对 Java 来说，它舍弃了很多 C++ 中难以理解的特性，如操作符的重载和多继承等，而且 Java 语言不使用指针，加入了垃圾回收机制，解决了程序员需要管理内存的问题，使编程变得更加简单。

**4. 解释执行**

Java 程序在 Java 平台运行时会被编译成字节码文件，然后可以在有 Java 环境的操作系统上运行。在运行文件时，Java 的解释器对这些字节码进行解释执行，执行过程中需要加入的类在连接阶段被载入到运行环境中。

**5. 多线程**

Java 语言是多线程的，这也是 Java 语言的一大特性，它必须由 Thread 类和它的子类来创建。Java 支持多个线程同时执行，并提供多线程之间的同步机制。任何一个线程都有自己的 run() 方法，要执行的方法就写在 run() 方法体内。

**6. 分布式**

Java 语言支持 Internet 应用的开发，在 Java 的基本应用编程接口中就有一个网络应用编程接口，它提供了网络应用编程的类库，包括 URL、URLConnection、Socket 等。Java 的 RIM 机制也是开发分布式应用的重要手段。

**7. 健壮性**

Java 的强类型机制、异常处理、垃圾回收机制等都是 Java 健壮性的重要保证。对指针的丢弃是 Java 的一大进步。另外，Java 的异常机制也是健壮性的一大体现。

**8. 高性能**

Java 的高性能主要是相对其他高级脚本语言来说的，随着 JIT（Just in Time）的发展，Java 的运行速度也越来越高。

**9. 安全性**

Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防止恶意代码的攻击。除了 Java 语言具有许多的安全特性以外，Java 还对通过网络下载的类增加一个安全防范机制，分配不同的名字空间以防替代本地的同名类，并包含安全管理机制。

Java 语言的众多特性使其在众多的编程语言中占有较大的市场份额，Java 语言对对象的支持和强大的 API 使得编程工作变得更加容易和快捷，大大降低了程序的开发成本。Java 的“一次编写，到处执行”正是它吸引众多商家和编程人员的一大优势。

### 2. JDK和JRE和JVM的区别
**1. JDK**

JDK（Java SE Development Kit），**Java标准的开发包，提供了编译、运行Java程序所需要的各种工具和资源**，包括了Java编译器、Java运行时环境、以及常用的Java类库等。



**2. JRE**

JRE（Java Runtime Environment）**，Java运行时环境，用于解释执行Java的字节码文件**。普通用户只需要安装JRE来运行Java程序即可，而作为一名程序员必须安装JDK，来编译、调试程序。



**3. JVM**

JVM（Java Virtual Mechinal），Java虚拟机，是JRE的一部分。**它是整个Java实现跨平台的核心**，负责解释执行字节码文件，是可运行Java字节码文件的虚拟计算机。所有平台上的JVM向编译器提供相同的接口，而编译器只需要面向虚拟机，生成虚拟机能识别的代码，然后由虚拟机来解释执行。

当使用Java编译器编译Java程序时，生成的是与平台无关的字节码，这些字节码只面向JVM。也就是说**JVM是运行Java字节码的虚拟机。**

不同平台的JVM是不同的，但是他们都提供了相同的接口。JVM是Java程序跨平台的关键部分，只要为不同平台实现了相同的虚拟机，编译后的Java字节码就可以在该平台上运行。



**为什么要采用字节码：**

> 在 Java 中，JVM 可以理解的代码就叫做`字节码`（即Java源代码经过虚拟机编译器编译后扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。



**什么是跨平台：**

> 所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。
>
> 实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。



**Java 程序从源代码到运行需要三步：**

![](https://gitee.com/gsjqwyl/images_repo/raw/master/2021-3-11/20210321015133.png)

**4. 总结**

1. JDK 用于开发，JRE 用于运行java程序 ；如果只是运行Java程序，可以只安装JRE，无序安装JDK。
2. JDk包含JRE，JDK 和 JRE 中都包含 JVM。
3. JVM 是 Java 编程语言的核心并且具有平台独立性。

### 3. 什么是跨平台性？原理是什么
*   所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。

*   实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。

### 4. Java程序是如何执行的
我们日常的工作中都使用开发工具（IntelliJ IDEA 或 Eclipse 等）可以很方便的调试程序，或者是通过打包工具把项目打包成 jar 包或者 war 包，放入 Tomcat 等 Web 容器中就可以正常运行了，但你有没有想过 Java 程序内部是如何执行的？其实不论是在开发工具中运行还是在 Tomcat 中运行，Java 程序的执行流程基本都是相同的，它的执行流程如下：

- 先把 Java 代码编译成字节码，也就是把 .java 类型的文件编译成 .class 类型的文件。这个过程的大致执行流程：Java 源代码 -> 词法分析器 -> 语法分析器 -> 语义分析器 -> 字符码生成器 -> 最终生成字节码，其中任何一个节点执行失败就会造成编译失败；
- 把 class 文件放置到 Java 虚拟机，这个虚拟机通常指的是 Oracle 官方自带的 Hotspot JVM；
- Java 虚拟机使用类加载器（Class Loader）装载 class 文件；
- 类加载完成之后，会进行字节码效验，字节码效验通过之后 JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以 Hotspot 虚拟机来说，它本身提供了 JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。Java 程序执行流程图如下：

![](https://gitee.com/gsjqwyl/images_repo/raw/master/2021-3-11/20210324143756.png)

### 5. Java SE 、Java EE 、Java ME

### 6. Oracle JDK 和 OpenJDK 的对比

### 7. Java和C++的区别

# 基础部分
### 1. instanceof 关键字的作用
instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：

```java
boolean result = obj instanceof Class
```

其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。

注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。

```java
int i = 0;
System.out.println(i instanceof Integer);//编译不通过  i必须是引用类型，不能是基本类型
System.out.println(i instanceof Object);//编译不通过
```

```java
Integer integer = new Integer(1);
System.out.println(integer instanceof  Integer);//true
```

```java
//false  　,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。
System.out.println(null instanceof Object);
```

### 2. == 和 equals 的区别是什么？
**"=="**

对于基本类型和引用类型 == 的作用效果是不同的，如下所示：

- 基本类型：比较的是值是否相同；
- 引用类型：比较的是引用是否相同；

```java
String x = "string";
String y = "string";
String z = new String("string");
System.out.println(x==y); // true
System.out.println(x==z); // false
System.out.println(x.equals(y)); // true
System.out.println(x.equals(z)); // true
```

> 因为 x 和 y 指向的是同一个引用，所以 == 也是 true，而 new String()方法则重写开辟了内存空间，所以 == 结果为 false，而 equals 比较的一直是值，所以结果都为 true。



**equals**

equals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。看下面的代码就明白了。

首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：

```java
class Cat {
    public Cat(String name) {
        this.name = name;
    }

    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

Cat c1 = new Cat("叶痕秋");
Cat c2 = new Cat("叶痕秋");
System.out.println(c1.equals(c2)); // false
```

输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：

```java
public boolean equals(Object obj) {
        return (this == obj);
}
```

原来 equals 本质上就是 ==。

那问题来了，两个相同值的 String 对象，为什么返回的是 true？代码如下：

```java
String s1 = new String("叶子");
String s2 = new String("叶子");
System.out.println(s1.equals(s2)); // true
```

同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：

```java
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。

**总结**

**== 对于基本类型来说是值比较，对于引用类型来说是比较的是引用；而 equals 默认情况下是引用比较，只是很多类重新了 equals 方法，比如 String、Integer 等把它变成了值比较，所以一般情况下 equals 比较的是值是否相等。**

### 3. Hashcode的作用
java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在set中插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法就会比较满。

于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。

hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。

### 4. 两个对象的 hashCode() 相同， 那么 equals() 也一定为 true吗？
不对，两个对象的 hashCode() 相同，equals() 不一定 true。

代码示例：

```java
String str1 = "keep";
String str2 = "brother";
System. out. println(String. format("str1：%d | str2：%d",  str1. hashCode(),str2. hashCode()));
System. out. println(str1. equals(str2));
```

执行结果:

```
str1：1179395 | str2：1179395

false
```

代码解读：很显然“keep”和“brother”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode() 相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。

### 5. 泛型常用特点
泛型是Java SE 1.5之后的特性， 《Java 核心技术》中对泛型的定义是：

> “泛型” 意味着编写的代码可以被不同类型的对象所重用。

“泛型”，顾名思义，“泛指的类型”。我们提供了泛指的概念，但具体执行的时候却可以有具体的规则来约束，比如我们用的非常多的ArrayList就是个泛型类，ArrayList作为集合可以存放各种元素，如Integer, String，自定义的各种类型等，但在我们使用的时候通过具体的规则来约束，如我们可以约束集合中只存放Integer类型的元素，如

```java
List<Integer> iniData = new ArrayList<>()
```

### 6. 使用泛型的好处？
以集合来举例，使用泛型的好处是我们不必因为添加元素类型的不同而定义不同类型的集合，如整型集合类，浮点型集合类，字符串集合类，我们可以定义一个集合来存放整型、浮点型，字符串型数据，而这并不是最重要的，因为我们只要把底层存储设置了Object即可，添加的数据全部都可向上转型为Object。 更重要的是我们可以通过规则按照自己的想法控制存储的数据类型。



### . 什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。

# 数据类型
### 1. Java有哪些数据类型

Java**中**有 8 种基本数据类型，分别为：

- **6 种数字类型 （四个整数形，两个浮点型）**：byte、short、int、long、float、double

- **1 种字符类型**：char
- **1 种布尔型**：boolean。

**byte：**

- byte 数据类型是8位、有符号的，以二进制补码表示的整数；
- 最小值是 **-128（-2^7）**；
- 最大值是 **127（2^7-1）**；
- 默认值是 **0**；
- byte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；
- 例子：byte a = 100，byte b = -50。

**short：**

- short 数据类型是 16 位、有符号的以二进制补码表示的整数
- 最小值是 **-32768（-2^15）**；
- 最大值是 **32767（2^15 - 1）**；
- Short 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；
- 默认值是 **0**；
- 例子：short s = 1000，short r = -20000。

**int：**

- int 数据类型是32位、有符号的以二进制补码表示的整数；
- 最小值是 **-2,147,483,648（-2^31）**；
- 最大值是 **2,147,483,647（2^31 - 1）**；
- 一般地整型变量默认为 int 类型；
- 默认值是 **0** ；
- 例子：int a = 100000, int b = -200000。

**long：**

- **注意：Java 里使用 long 类型的数据一定要在数值后面加上 L，否则将作为整型解析**

- long 数据类型是 64 位、有符号的以二进制补码表示的整数；
- 最小值是 **-9,223,372,036,854,775,808（-2^63）**；
- 最大值是 **9,223,372,036,854,775,807（2^63 -1）**；
- 这种类型主要使用在需要比较大整数的系统上；
- 默认值是 **0L**；
- 例子： long a = 100000L，Long b = -200000L。
  "L"理论上不分大小写，但是若写成"l"容易与数字"1"混淆，不容易分辩。所以最好大写。

**float：**

- float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；
- float 在储存大型浮点数组的时候可节省内存空间；
- 默认值是 **0.0f**；
- 浮点数不能用来表示精确的值，如货币；
- 例子：float f1 = 234.5f。

**double：**

- double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；
- 浮点数的默认类型为double类型；
- double类型同样不能表示精确的值，如货币；
- 默认值是 **0.0d**；
- 例子：double d1 = 123.4。

**char：**

- char类型是一个单一的 16 位 Unicode 字符；
- 最小值是 **\u0000**（即为 0）；
- 最大值是 **\uffff**（即为 65535）；
- char 数据类型可以储存任何字符；
- 例子：char letter = 'A';（**单引号**）

**boolean：**

- boolean数据类型表示一位的信息；
- 只有两个取值：true 和 false；
- 这种类型只作为一种标志来记录 true/false 情况；
- 默认值是 **false**；
- 例子：boolean one = true。

**这八种基本类型都有对应的包装类分别为：Byte、Short、Integer、Long、Float、Double、Character、Boolean**

| 类型名称     | 字节、位数            | 最小值                                         | 最大值                                 | 默认值           | 例子                                |
| :----------- | :-------------------- | :--------------------------------------------- | :------------------------------------- | :--------------- | :---------------------------------- |
| byte字节     | 1字节，8位            | -128（-2^7）                                   | 127（2^7-1）                           | 0                | byte a = 100，byte b = -50          |
| short短整型  | 2字节，16位           | -32768（-2^15）                                | 32767（2^15 - 1）                      | 0                | short s = 1000，short r = -20000    |
| int整形      | 4字节，32位           | -2,147,483,648（-2^31）                        | 2,147,483,647（2^31 - 1）              | 0                | int a = 100000, int b = -200000     |
| lang长整型   | 8字节，64位           | -9,223,372,036,854,775,808（-2^63）            | 9,223,372,036,854,775,807（2^63 -1）   | 0L               | long a = 100000L，Long b = -200000L |
| double双精度 | 8字节，64位           |                                                | double类型同样不能表示精确的值，如货币 | 0.0d             | double d1 = 123.4                   |
| float单精度  | 4字节，32位           | 在储存大型浮点数组的时候可节省内存空间         | 不同统计精准的货币值                   | 0.0f             | float f1 = 234.5f                   |
| char字符     | 2字节，16位           | \u0000（即为0）                                | \uffff（即为65,535）                   | 可以储存任何字符 | char letter = 'A';                  |
| boolean布尔  | 返回true和false两个值 | 这种类型只作为一种标志来记录 true/false 情况； | 只有两个取值：true 和 false；          | false            | boolean one = true                  |

### 2. Java中引用数据类型有哪些，它们与基本数据类型有什么区别？
引用数据类型分3种：类，接口，数组；

**简单来说,只要不是基本数据类型.都是引用数据类型。 那他们有什么不同呢？**



**1、从概念方面来说**

1,基本数据类型:变量名指向具体的数值

2,引用数据类型:变量名不是指向具体的数值,而是指向存数据的内存地址,.也及时hash值



**2、从内存的构建方面来说**(内存中,有堆内存和栈内存两者)

1,基本数据类型:被创建时,在栈内存中会被划分出一定的内存,并将数值存储在该内存中.

2,引用数据类型:被创建时,首先会在栈内存中分配一块空间,然后在堆内存中也会分配一块具体的空间用来存储数据的具体信息,即hash值,然后由栈中引用指向堆中的对象地址.



**举个例子**

```java
//基本数据类型作为方法参数被调用
public class Main{
	public static void main(String[] args){
		//基本数据类型
		int i = 1;
		int j = 1;
		double d = 1.2;
 
		//引用数据类型
		String str = "Hello";
		String str1= "Hello";
	}
}
```



![](https://gitee.com/gsjqwyl/images_repo/raw/master/2021-3-11/20210322011647.png)

由上图可知，基本数据类型中会存在两个相同的1，而引用型类型就不会存在相同的数据。
假如"hello"的引用地址是xxxxx1，声明str变量并其赋值"hello"实际上就是让str变量引用了"hello"的内存地址，这个内存地址就存储在堆内存中，是不会改变的，当再次声明变量str1也是赋值为"hello"时，此时就会在堆内存中查询是否有"hello"这个地址，如果堆内存中已经存在这个地址了，就不会再次创建了，而是让str1变量也指向xxxxx1这个地址，如果没有的话，就会重新创建一个地址给str1变量。



**从使用方面来说**

1,基本数据类型:判断数据是否相等，用==和!=判断。
2,引用数据类型:判断数据是否相等，用equals()方法,==和!=是比较数值的。而equals()方法是比较内存地址的。

**补充：数据类型选择的原则**

- 如果要表示整数就使用int，表示小数就使用double；
- 如果要描述日期时间数字或者表示文件（或内存）大小用long；
- 如果要实现内容传递或者编码转换使用byte；
- 如果要实现逻辑的控制，可以使用booleam；
- 如果要使用中文，使用char避免中文乱码；
- 如果按照保存范围：byte < int < long < double;


### 3. 自动装箱与拆箱
**什么是自动装箱拆箱？**

从下面的代码中就可以看到装箱和拆箱的过程

```java
//自动装箱
Integer total = 99;

//自定拆箱
int totalprim = total;
```

**装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。**

> 在Java SE5之前，自动装箱要这样写：Integer i = ``new` `Integer(``10``);



对于Java的自动装箱和拆箱，我们看看源码编译后的class文件，其实装箱调用包装类的valueOf方法，拆箱调用的是Integer.Value方法，下面就是变编译后的代码：

![](https://gitee.com/gsjqwyl/images_repo/raw/master/2021-3-11/20210322151715.png)



**常见面试一：**

这段代码输出什么？

```java
public class Main {
    public static void main(String[] args) {
         
        Integer i1 = 100;
        Integer i2 = 100;
        Integer i3 = 200;
        Integer i4 = 200;
         
        System.out.println(i1==i2);
        System.out.println(i3==i4);
    }
}
```

答案是:

```
true
false
```

为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现：

```java
public static Integer valueOf(int i) {
        if(i >= -128 && i <= IntegerCache.high)
            return IntegerCache.cache[i + 128];
        else
            return new Integer(i);
    }
```



```java
private static class IntegerCache {
        static final int high;
        static final Integer cache[];

        static {
            final int low = -128;

            // high value may be configured by property
            int h = 127;
            if (integerCacheHighPropValue != null) {
                // Use Long.decode here to avoid invoking methods that
                // require Integer's autoboxing cache to be initialized
                int i = Long.decode(integerCacheHighPropValue).intValue();
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - -low);
            }
            high = h;

            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k < cache.length; k++)
                cache[k] = new Integer(j++);
        }

        private IntegerCache() {}
    }
```



从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。

上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。



**常见面试二：**

```java
public class Main {
    public static void main(String[] args) {
         
        Double i1 = 100.0;
        Double i2 = 100.0;
        Double i3 = 200.0;
        Double i4 = 200.0;
         
        System.out.println(i1==i2);
        System.out.println(i3==i4);
    }
}
```

输出结果为：

```
false
false
```

原因很简单，在某个范围内的整型数值的个数是有限的，而浮点数却不是。



### 4. int 和 Integer 有什么区别
* Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。

* Java 为每个原始类型提供了包装类型：

    * 原始类型: boolean，char，byte，short，int，long，float，double

        * 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double


### 4. Integer a= 127 与 Integer b = 127相等吗
*   对于对象引用类型：==比较的是对象的内存地址。
*   对于基本数据类型：==比较的是值。

`如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false`

```java
public static void main(String[] args) {
    Integer a = new Integer(3);
    Integer b = 3;  // 将3自动装箱成Integer类型
  int c = 3;
    System.out.println(a == b); // false 两个引用没有引用同一对象
  System.out.println(a == c); // true a自动拆箱成int类型再和c比较
  System.out.println(b == c); // true

    Integer a1 = 128;
    Integer b1 = 128;
    System.out.println(a1 == b1); // false

    Integer a2 = 127;
    Integer b2 = 127;
    System.out.println(a2 == b2); // true
}
```

### 5. short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗
*   对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。

*   而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。

### Java的四种引用，强弱软虚

# 常见关键字
### 1. final 在 Java 中有什么作用？
final作为Java中的关键字可以用于三个地方。用于修饰类、类属性和类方法。

特征：凡是引用final关键字的地方皆不可修改！

(1)修饰类：表示该类不能被继承；

(2)修饰方法：表示方法不能被重写；

(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。

### 2.访问修饰符 public,private,protected,以及不写（默认）时的区别
*   **定义**：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。

*   **分类**

    *   **private**  : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）

    *   **default** (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

    *   **protected**  : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。

    *   **public** : 对所有类可见。使用对象：类、接口、变量、方法

**访问修饰符图**

![在这里插入图片描述](https://user-gold-cdn.xitu.io/2020/4/14/171744c433bcfd38?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 3. final 有什么用？
用于修饰类、属性和方法

*   被final修饰的类不可以被继承
*   被final修饰的方法不可以被重写
*   被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的

### 4. final有哪些用法?
final也是很多面试喜欢问的地方,但我觉得这个问题很无聊,通常能回答下以下5点就不错了:

- 被final修饰的类不可以被继承
- 被final修饰的方法不可以被重写
- 被final修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变.
- 被final修饰的方法,JVM会尝试将其内联,以提高运行效率
- 被final修饰的常量,在编译阶段会存入常量池中.

除此之外,编译器对final域要遵守的两个重排序规则更好:

在构造函数内对一个final域的写入,与随后把这个被构造对象的引用赋值给一个引用变量,这两个操作之间不能重排序 初次读一个包含final域的对象的引用,与随后初次读这个final域,这两个操作之间不能重排序.

### 5. static都有哪些用法?
所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量/方法都属于类的静态资源,类实例所共享.

除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:

```java
public calss PreCache{
    static{
        //执行相关操作
    }
}
```

此外static也多用于修饰内部类,此时称之为静态内部类.

最后一种用法就是静态导包,即`import static`.import static是在JDK 1.5之后引入的新特性,可以用来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:

```java
import static java.lang.Math.*;
 
public class Test{
 
    public static void main(String[] args){
        //System.out.println(Math.sin(20));传统做法
        System.out.println(sin(20));
    }
}
```

### 6. static和final区别

| 关键词 | 修饰物 | 影响                                                     |
| :----- | :----- | :------------------------------------------------------- |
| final  | 变量   | 分配到常量池中，程序不可改变其值                         |
| final  | 方法   | 子类中将不能被重写                                       |
| final  | 类     | 不能被继承                                               |
| static | 变量   | 分配在内存堆上，引用都会指向这一个地址而不会重新分配内存 |
| static | 方法块 | 虚拟机优先加载                                           |
| static | 类     | 可以直接通过类来调用而不需要new                          |


### 7. this关键字的用法
* this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。

* this的用法在java中大体可以分为3种：

    *   1.普通的直接引用，this相当于是指向当前对象本身。

    *   2.形参与成员名字重名，用this来区分：

  ```java
  public Person(String name, int age) {
      this.name = name;
      this.age = age;
  }
  ```

    *   3.引用本类的构造函数

  ```java
  class Person{
      private String name;
      private int age;
  
      public Person() {
      }
  
      public Person(String name) {
          this.name = name;
      }
      public Person(String name, int age) {
          this(name);
          this.age = age;
      }
  }
  ```

### 8. super关键字的用法
super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。

**super也有三种用法：**

*   1.普通的直接引用

与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。

*   2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分

  ```java
        class Person{
            protected String name;
  
            public Person(String name) {
                this.name = name;
            }
  
        }
  
        class Student extends Person{
            private String name;
  
            public Student(String name, String name1) {
                super(name);
                this.name = name1;
            }
  
            public void getInfo(){
                System.out.println(this.name);      //Child
                System.out.println(super.name);     //Father
            }
  
        }
  
        public class Test {
            public static void main(String[] args) {
               Student s1 = new Student("Father","Child");
               s1.getInfo();
  
            }
        }
  
  ```

3.引用父类构造函数

*   super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。
*   this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。


### 9. &和&&的区别

*   &运算符有两种用法：(1)按位与；(2)逻辑与。

*   &&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&&之所以称为短路运算，是因为如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。

`注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。`



###  10. break ,continue ,return 的区别及作用

*   break 跳出总上一层循环，不再执行循环(结束当前的循环体)
*   continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)
*   return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)

# 异常处理
### 1. Java异常简介

Java异常是Java提供的一种识别及响应错误的一致性机制。

Java异常机制可以使程序中异常处理代码和正常业务代码分离，保证程序代码更加优雅，并提高程序健壮性。在有效使用异常的情况下，异常能清晰的回答what, where, why这3个问题：异常类型回答了“什么”被抛出，异常堆栈跟踪回答了“在哪”抛出，异常信息回答了“为什么”会抛出。



### 2. Java异常架构

![image-20210814134319791](https://gitee.com/gsjqwyl/images/raw/master/uPic/tu731M.jpg)

### 3. Error 和 Exception 有什么区别？

**Error ** 

表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；

**Exception  ** 

表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。



### 4. 阐述 final、finally、finalize 的区别

**1、final：** 修饰符（关键字）有三种用法：如果一个类被声明为 final，意味着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。将变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final 的方法也同样只能使用，不能在子类中被重写。

**2、finally：** 通常放在 try…catch…的后面构造总是执行代码块，这就意味着程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以将释放外部资源的代码写在 finally 块中.

**3、finalize：** Object 类中定义的方法，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize()方法可以整理系统资源或者执行其他清理工作。

### 5. 列出一些你常见的运行时异常？

### 6. 什么是受检异常

### 7. Excption与Error包结构

更多异常面试题及答案，都整理成了PDF: [完整版Java面试高清PDF合集](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/index.md)

# Java集合 & 容器
### 什么是集合

*   集合就是一个放数据的容器，准确的说是放数据对象引用的容器

*   集合类存放的都是对象的引用，而不是对象的本身

*   集合类型主要有3种：set(集）、list(列表）和map(映射)。


### 集合的特点
*   集合的特点主要有如下两点：
*   集合用于存储对象的容器，对象是用来封装数据，对象多了也需要存储集中式管理。

*   和数组对比对象的大小不确定。因为集合是可变长度的。数组需要提前定义大小


### 集合和数组的区别

*   数组是固定长度的；集合可变长度的。

*   数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。

*   数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。


### 使用集合框架的好处

1.  容量自增长；
2.  提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；
3.  可以方便地扩展或改写集合，提高代码复用性和可操作性。
4.  通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。


### 常用的集合类有哪些？

*   Map接口和Collection接口是所有集合框架的父接口：

1. Collection接口的子接口包括：Set接口和List接口
2. Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等
3. Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等
4. List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等

### ArrayList和HashMap默认大小?

在 java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16个元素（必须是2的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段

```java
private static final int DEFAULT_CAPACITY = 10;

 //from HashMap.java JDK 7
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
```

### List，Set，Map三者的区别？

### List、Map、Set三个接口，存取元素时，各有什么特点？

### 集合框架底层数据结构

### poll()方法和remove()方法区别?

### ArrayList,Vector,LinkedList的存储性能和特性

### ArrayList和Array有什么区别?

## 更多Java集合 & 容器面试题：  [Java集合 & 容器 面试题](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/base/Java%E9%9B%86%E5%90%88&%E5%AE%B9%E5%99%A8.md)

完整PDF下载：[高清Java面试合集 PDF 下载](https://gitee.com/tiger-a/java-interview/blob/master/interviewDoc/Java/qr.md)


Array可以容纳基本类型和对象，而ArrayList只能容纳对象。

ArrayList 是Java集合框架类的一员,可以称它为一个动态数组. array 是静态的,所以一个数据一旦创建就无法更改他的大小