**所有问题以及答案，我都整理成了高清PDF，并且带目录：[Java面试整理高清PDF下载](https://mp.weixin.qq.com/s?__biz=MzI1MTQ3MDM1MA==&mid=100002266&idx=1&sn=00a44a2cbef83cd4f6ab45c5bb1725e7&chksm=69f33ebb5e84b7ad89740f7ca8aacc0aa56b29b44e6242d2089a2fec3a3b742b9b5fce82557f#rd)**

**所有问题以及答案，我都整理成了高清PDF，并且带目录：[Java面试整理高清PDF下载](https://mp.weixin.qq.com/s?__biz=MzI1MTQ3MDM1MA==&mid=100002266&idx=1&sn=00a44a2cbef83cd4f6ab45c5bb1725e7&chksm=69f33ebb5e84b7ad89740f7ca8aacc0aa56b29b44e6242d2089a2fec3a3b742b9b5fce82557f#rd)**

**所有问题以及答案，我都整理成了高清PDF，并且带目录：[Java面试整理高清PDF下载](https://mp.weixin.qq.com/s?__biz=MzI1MTQ3MDM1MA==&mid=100002266&idx=1&sn=00a44a2cbef83cd4f6ab45c5bb1725e7&chksm=69f33ebb5e84b7ad89740f7ca8aacc0aa56b29b44e6242d2089a2fec3a3b742b9b5fce82557f#rd)**


<!-- TOC -->

- [什么是网络编程](#什么是网络编程)
- [网络编程中两个主要的问题](#网络编程中两个主要的问题)
- [网络协议是什么](#网络协议是什么)
- [为什么要对网络协议分层](#为什么要对网络协议分层)
- [计算机网络体系结构](#计算机网络体系结构)
- [什么是TCP/IP和UDP](#什么是tcpip和udp)
- [TCP/IP 四层模型](#tcpip-四层模型)
- [TCP与UDP区别：](#tcp与udp区别)
- [TCP和UDP的应用场景：](#tcp和udp的应用场景)
- [形容一下TCP和UDP](#形容一下tcp和udp)
- [从浏览器地址栏输入url到显示主页的过程](#从浏览器地址栏输入url到显示主页的过程)
- [说说OSI 七层、TCP/IP 四层的关系和区别？](#说说osi-七层tcpip-四层的关系和区别)
- [说说TCP 与 UDP 的区别？](#说说tcp-与-udp-的区别)
- [TCP 是如何实现数据的可靠性？](#tcp-是如何实现数据的可靠性)
- [你知道 TCP 如何处理拥塞吗？](#你知道-tcp-如何处理拥塞吗)
- [运行在TCP 或UDP的应用层协议分析。](#运行在tcp-或udp的应用层协议分析)
- [什么是Http协议？](#什么是http协议)
- [说说HTTP常用的状态码及其含义？](#说说http常用的状态码及其含义)
- [Http和Https的区别？](#http和https的区别)
- [讲一下 http1.1 和 http2 有什么区别？](#讲一下-http11-和-http2-有什么区别)
- [什么是http的请求体？](#什么是http的请求体)
- [HTTP的响应报文有哪些？](#http的响应报文有哪些)
- [Http中常见的header字段有哪些？](#http中常见的header字段有哪些)
- [HTTPS工作原理](#https工作原理)
- [讲一下三次握手和四次挥手全过程](#讲一下三次握手和四次挥手全过程)
- [三次握手与四次挥手](#三次握手与四次挥手)
- [为什么 TCP 链接需要三次握手，两次不可以么？](#为什么-tcp-链接需要三次握手两次不可以么)
- [用现实理解三次握手的具体细节](#用现实理解三次握手的具体细节)
- [建立连接可以两次握手吗？为什么?](#建立连接可以两次握手吗为什么)
- [为什么要四次挥手？](#为什么要四次挥手)
- [IP地址是怎样分类的，你知道吗？](#ip地址是怎样分类的你知道吗)
- [TCP 协议如何来保证传输的可靠性](#tcp-协议如何来保证传输的可靠性)
- [客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？](#客户端不断进行请求链接会怎样ddosdistributed-denial-of-service攻击)
- [GET 与 POST 的区别？](#get-与-post-的区别)
- [为什么在GET请求中会对URL进行编码？](#为什么在get请求中会对url进行编码)
- [TCP与UDP的区别](#tcp与udp的区别)
- [TCP和UDP分别对应的常见应用层协议](#tcp和udp分别对应的常见应用层协议)
- [DNS的寻址过程你知道吗？](#dns的寻址过程你知道吗)
- [TCP 的拥塞避免机制](#tcp-的拥塞避免机制)
- [什么是Socket](#什么是socket)
- [Socket属于网络的那个层面](#socket属于网络的那个层面)
- [Socket通讯的过程](#socket通讯的过程)
- [Socket和http的区别和应用场景](#socket和http的区别和应用场景)
- [一次完整的HTTP请求所经历几个步骤?](#一次完整的http请求所经历几个步骤)
- [浏览器中输入：“`www.xxx.com`” 之后都发生了什么？请详细阐述。](#浏览器中输入wwwxxxcom-之后都发生了什么请详细阐述)
- [什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?](#什么是-http-协议无状态协议怎么解决http协议无状态协议)
- [Session、Cookie 与 Application](#sessioncookie-与-application)
- [有哪些 web 性能优化技术?](#有哪些-web-性能优化技术)
- [什么是 XSS 攻击？](#什么是-xss-攻击)
- [什么是跨站攻击CSRF？](#什么是跨站攻击csrf)
- [滑动窗口机制](#滑动窗口机制)
- [常用的HTTP方法有哪些？](#常用的http方法有哪些)
- [常见HTTP状态码](#常见http状态码)
- [SQL 注入](#sql-注入)
- [XSS 攻击](#xss-攻击)
- [OSI 网络体系结构与 TCP/IP 协议模型](#osi-网络体系结构与-tcpip-协议模型)
- [网络层的 ARP 协议工作原理？](#网络层的-arp-协议工作原理)
- [IP地址的分类](#ip地址的分类)
- [IP地址与物理地址](#ip地址与物理地址)
- [影响网络传输的因素有哪些？](#影响网络传输的因素有哪些)
- [什么是对称加密与非对称加密](#什么是对称加密与非对称加密)
- [你知道对称加密和非对称加密的区别和原理吗？](#你知道对称加密和非对称加密的区别和原理吗)
- [什么是Cookie](#什么是cookie)
- [什么是Session](#什么是session)
- [Cookie和Session对于HTTP有什么用？](#cookie和session对于http有什么用)
- [Cookie与Session区别](#cookie与session区别)

<!-- /TOC -->

### 什么是网络编程

- 网络编程的本质是多台计算机之间的数据交换。数据传递本身没有多大的难度，不就是把一个设备中的数据发送给其他设备，然后接受另外一个设备反馈的数据。现在的网络编程基本上都是基于请求/响应方式的，也就是一个设备发送请求数据给另外一个，然后接收另一个设备的反馈。在网络编程中，发起连接程序，也就是发送第一次请求的程序，被称作客户端(Client)，等待其他程序连接的程序被称作服务器(Server)。客户端程序可以在需要的时候启动，而服务器为了能够时刻相应连接，则需要一直启动。

- 例如以打电话为例，首先拨号的人类似于客户端，接听电话的人必须保持电话畅通类似于服务器。连接一旦建立以后，就客户端和服务器端就可以进行数据传递了，而且两者的身份是等价的。在一些程序中，程序既有客户端功能也有服务器端功能，最常见的软件就是QQ、微信这类软件了。



### 网络编程中两个主要的问题

**1、**一个是如何准确的定位网络上一台或多台主机，

**2、**另一个就是找到主机后如何可靠高效的进行数据传输。

- 在TCP/IP协议中IP层主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定Internet上的一台主机。
- 而TCP层则提供面向应用的可靠（TCP）的或非可靠（UDP）的数据传输机制，这是网络编程的主要对象，一般不需要关心IP层是如何处理数据的。
- 目前较为流行的网络编程模型是客户机/服务器（C/S）结构。即通信双方一方作为服务器等待客户提出请求并予以响应。客户则在需要服务时向服务器提 出申请。服务器一般作为守护进程始终运行，监听网络端口，一旦有客户请求，就会启动一个服务进程来响应该客户，同时自己继续监听服务端口，使后来的客户也 能及时得到服务。



### 网络协议是什么

在计算机网络要做到井井有条的交换数据，就必须遵守一些事先约定好的规则，比如交换数据的格式、是否需要发送一个应答信息。这些规则被称为网络协议。



### 为什么要对网络协议分层

**1、**简化问题难度和复杂度。由于各层之间独立，我们可以分割大问题为小问题。

**2、**灵活性好。当其中一层的技术变化时，只要层间接口关系保持不变，其他层不受影响。

**3、**易于实现和维护。

**4、**促进标准化工作。分开后，每层功能可以相对简单地被描述



### 计算机网络体系结构

![](https://gitee.com/gsjqwyl/images_repo/raw/master/2021-3-11/20210325175839.png).

**OSI参考模型**

- OSI（Open System Interconnect），即开放式系统互联。一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及，推出了OSI参考模型，这样所有的公司都按照统一的标准来指定自己的网络，就可以互通互联了。
- OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层）。

![](https://gitee.com/gsjqwyl/images_repo/raw/master/2021-3-11/20210325175940.png)



**TCP/IP参考模型**

TCP/IP四层协议（数据链路层、网络层、传输层、应用层）

**1、**应用层 应用层最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，TELNET等。

**2、**传输层 建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。

**3、**网络层 本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。

**4、**数据链路层 通过一些规程或协议来控制这些数据的传输，以保证被传输数据的正确性。实现这些规程或协议的`硬件`和软件加到物理线路，这样就构成了数据链路，



### 什么是TCP/IP和UDP

**1、**TCP/IP即传输控制/网络协议，是面向连接的协议，发送数据前要先建立连接(发送方和接收方的成对的两个之间必须建 立连接)，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达

**2、**UDP它是属于TCP/IP协议族中的一种。是无连接的协议，发送数据前不需要建立连接，是没有可靠性的协议。因为不需要建立连接所以可以在在网络上以任何可能的路径传输，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能被保证的。



### TCP/IP 四层模型

- 应用层：对应于OSI参考模型的（应用层、表示层、会话层）。

- 传输层: 对应OSI的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。
- 网际层：对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。
- 网络接口层：与OSI参考模型的数据链路层、物理层对应。



### TCP与UDP区别：

**1、**TCP是面向连接的协议，发送数据前要先建立连接，TCP提供可靠的服务，也就是说，通过TCP连接传输的数据不会丢失，没有重复，并且按顺序到达；

**2、**UDP是无连接的协议，发送数据前不需要建立连接，是没有可靠性；

**3、**TCP通信类似于于要打个电话，接通了，确认身份后，才开始进行通行；

**4、**UDP通信类似于学校广播，靠着广播播报直接进行通信。

**5、**TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；

**6、**TCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。

**7、**TCP首部开销（20字节）比UDP首部开销（8字节）要大

**8、**UDP 的主机不需要维持复杂的连接状态表



### TCP和UDP的应用场景：

对某些实时性要求比较高的情况使用UDP，比如游戏，媒体通信，实时直播，即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失的情况



### 形容一下TCP和UDP

**TCP通信可看作打电话：**

李三(拨了个号码)：喂，是王五吗？ 王五：哎，您谁啊？ 李三：我是李三，我想给你说点事儿，你现在方便吗？ 王五：哦，我现在方便，你说吧。 甲：那我说了啊？ 乙：你说吧。 (连接建立了，接下来就是说正事了…)

**UDP通信可看为学校里的广播：**

播音室：喂喂喂！全体操场集合



### 从浏览器地址栏输入url到显示主页的过程

**思路:** 这道题主要考察的知识点是HTTP的请求过程，**DNS解析，TCP三次握手，四次挥手这几个要点**，我们都可以讲下。

1. DNS解析，查找域名对应的IP地址。
2. 与服务器通过三次握手，建立TCP连接
3. 向服务器发送HTTP请求
4. 服务器处理请求，返回网页内容
5. 浏览器解析并渲染页面
6. TCP四次挥手，连接结束

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzZhoE6C26ico3G8O3LAOicSszL5ibsib9aJibTb0KtwnHFA657cdbO9yYRtibed4uJOuUYOxzTibd37DZQg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)





### 说说OSI 七层、TCP/IP 四层的关系和区别？

**OSI 七层从下往上依次是：`物理层`、`数据链路层`、`网络层`、`传输层`、`会话层`、`表示层`、`应用层`。**

一张图给你整明白：

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoYnryQ9Kc2y05brZXs3oT6BGVULKLmVRwBBGdVdadIu5TtJHLAqiaMlk7rGh7BvdicYFvSHibkHeGYw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

TCP/IP 四层从下往上依次是：`网络接口层`、`网络层`、`传输层`、`应用层`。与 OSI 七层的映射关系如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoYnryQ9Kc2y05brZXs3oT6qJoymBkOAoMX4OGHjjT2bVWThibf2up6ktoAYNaAVSARFRO8YUN02ew/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**特点：**

- 层与层之间相互独立又相互依靠
- 上层依赖于下层，下层为上层提供服务

**敲黑板：TCP/IP 四层是 OSI 七层的简化版，已经成为实事国际标准。**



### 说说TCP 与 UDP 的区别？

先上一张对比图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoYnryQ9Kc2y05brZXs3oT6JWGAt961MQ6b8T86GqWmAk3S6qH1lnl3eEjaZy5MjCcrGC19n2shbA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**总结**

- TCP 向上层提供面向连接的可靠服务 ，UDP 向上层提供无连接不可靠服务。
- UDP 没有 TCP 传输可靠，但是可以在实时性要求搞的地方有所作为。
- 对数据准确性要求高，速度可以相对较慢的，可以选用TCP。



### TCP 是如何实现数据的可靠性？

一句话：通过`校验和`、`序列号`、`确认应答`、`超时重传`、`连接管理`、`流量控制`、`拥塞控制`等机制来保证可靠性。

**（1）校验和**

在数据传输过程中，将发送的数据段都当做一个16位的整数，将这些整数加起来，并且前面的进位不能丢弃，补在最后，然后取反，得到校验和。

发送方：在发送数据之前计算校验和，并进行校验和的填充。接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方进行比较。

**（2）序列号**

TCP 传输时将每个字节的数据都进行了编号，这就是序列号。序列号的作用不仅仅是应答作用，有了序列号能够将接收到的数据根据序列号进行排序，并且去掉重复的数据。

**（3）确认应答**

TCP 传输过程中，每次接收方接收到数据后，都会对传输方进行确认应答，也就是发送 ACK 报文，这个 ACK 报文中带有对应的确认序列号，告诉发送方，接收了哪些数据，下一次数据从哪里传。

**（4）超时重传**

在进行 TCP 传输时，由于存在确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的 ACK 报文，并解析 ACK 报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟都没有接收到接收方传来的 ACK 报文，那么就对刚刚发送的数据进行重发。

**（5）连接管理**

就是指三次握手、四次挥手的过程。

**（6）流量控制**

如果发送方的发送速度太快，会导致接收方的接收缓冲区填充满了，这时候继续传输数据，就会造成大量丢包，进而引起丢包重传等等一系列问题。TCP 支持根据接收端的处理能力来决定发送端的发送速度，这就是流量控制机制。

具体实现方式：接收端将自己的接收缓冲区大小放入 TCP 首部的『窗口大小』字段中，通过 ACK 通知发送端。

**（7）拥塞控制**

TCP 传输过程中一开始就发送大量数据，如果当时网络非常拥堵，可能会造成拥堵加剧。所以 TCP 引入了`慢启动机制`，在开始发送数据的时候，先发少量的数据探探路。



### 你知道 TCP 如何处理拥塞吗？

网络拥塞现象是指到达通信网络中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。

拥塞控制的四个阶段:

- 慢启动
- 拥塞避免
- 快速重传
- 快速恢复



### 运行在TCP 或UDP的应用层协议分析。

**运行在TCP协议上的协议：**

- HTTP（Hypertext Transfer Protocol，超文本传输协议），主要用于普通浏览。
- HTTPS（HTTP over SSL，安全超文本传输协议）,HTTP协议的安全版本。
- FTP（File Transfer Protocol，文件传输协议），用于文件传输。
- POP3（Post Office Protocol, version 3，邮局协议），收邮件用。
- SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），用来发送电子邮件。
- TELNET（Teletype over the Network，网络电传），通过一个终端（terminal）登陆到网络。
- SSH（Secure Shell，用于替代安全性差的TELNET），用于加密安全登陆用。

**运行在UDP协议上的协议：**

- BOOTP（Boot Protocol，启动协议），应用于无盘设备。
- NTP（Network Time Protocol，网络时间协议），用于网络同步。
- DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。

**运行在TCP和UDP协议上：**

- DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作。
- ECHO（Echo Protocol，回绕协议），用于查错及测量应答时间（运行在[TCP](http://zh.wikipedia.org/zh-cn/TCP)和[UDP](http://zh.wikipedia.org/zh-cn/UDP)协议上）。
- SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。
- DHCP（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。
- ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。



### 什么是Http协议？

- Http协议是对客户端和服务器端之间数据之间实现可靠性的传输文字、图片、音频、视频等超文本数据的规范，格式简称为“超文本传输协议”
- Http协议属于应用层，及用户访问的第一层就是http

![](https://gitee.com/gsjqwyl/images_repo/raw/master/2021-3-11/20210326001352.png)





### 说说HTTP常用的状态码及其含义？

**思路:** 这道面试题主要考察候选人，是否掌握HTTP状态码这个基础知识点。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzZhoE6C26ico3G8O3LAOicSsA1ibrAEaWJLpdCxZ7zAmq1OhHJbrosmaPU3wNH85LOL6icvWIWQibUn0w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**不管是不是面试需要，我们都要知道，日常开发中的这几个状态码的含义哈：**

![图片](https://mmbiz.qpic.cn/mmbiz_png/PoF8jo1PmpzZhoE6C26ico3G8O3LAOicSsSRpYffO9yCxGmQUH28ibCjkFTb0oyGDx5fGF55b0b8md1sUKMm2X52g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



### Http和Https的区别？

Http协议运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份；Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP。二者之间存在如下不同：

- 端口不同：Http与Http使用不同的连接方式，用的端口也不一样，前者是80，后者是443；
- 资源消耗：和HTTP通信相比，Https通信会由于加减密处理消耗更多的CPU和内存资源；
- 开销：Https通信需要证书，而证书一般需要向认证机构购买；

Https的加密机制是一种共享密钥加密和公开密钥加密并用的混合加密机制。



### 讲一下 http1.1 和 http2 有什么区别？

**HTTP1.1**

- 持久连接
- 请求管道化
- 增加缓存处理（新的字段如cache-control）
- 增加 Host 字段、支持断点传输等

**HTTP2.0**

- 二进制分帧
- 多路复用（或连接共享）
- 头部压缩
- 服务器推送



### 什么是http的请求体？

**1、**HTTP请求体是我们请求数据时先发送给服务器的数据，毕竟我向服务器那数据，先要表明我要什么吧

**2、**HTTP请求体由：请求行 、请求头、请求数据组成的，

**3、**注意：GIT请求是没有请求体的

**POST请求**

![](https://gitee.com/gsjqwyl/images_repo/raw/master/2021-3-11/20210326001732.png)



**GET请求是没有请求体的**

![](https://gitee.com/gsjqwyl/images_repo/raw/master/2021-3-11/20210326001814.png)





### HTTP的响应报文有哪些？

**1、**http的响应报是服务器返回给我们的数据，必须先有请求体再有响应报文

**2、**响应报文包含三部分 状态行、响应首部字段、响应内容实体实现

![](https://gitee.com/gsjqwyl/images_repo/raw/master/2021-3-11/20210326001902.png)



### Http中常见的header字段有哪些？

cookie，请求时传递给服务端的cookie信息 set-cookie，响应报文首部设置要传递给客户端的cookie信息 allow，支持什么HTTP方法 last-modified，资源的最后修改时间 expires,设置资源缓存的失败日期 content-language，实体的资源语言 content-encoding，实体的编码格式 content-length，实体主体部分的大小单位是字节 content-range，返回的实体的哪些范围 content-type，哪些类型 accept-ranges，处理的范围请求 age，告诉客户端服务器在多久前创建了响应 vary，代理服务器的缓存信息 location，用于指定重定向后的URI If-Match，值是资源的唯一标识 User-Agent，将创建请求的浏览器和用户代理名称等信息传递给服务器 Transfer-Encoding，传输报文的主体编码方式 connection，管理持久连接，keep-alive , close Cache-Control，控制浏览器的强缓存



### HTTPS工作原理

**1、**首先HTTP请求服务端生成证书，客户端对证书的有效期、合法性、域名是否与请求的域名一致、证书的公钥（RSA加密）等进行校验；

**2、**客户端如果校验通过后，就根据证书的公钥的有效， 生成随机数，随机数使用公钥进行加密（RSA加密）；

**3、**消息体产生的后，对它的摘要进行MD5（或者SHA1）算法加密，此时就得到了RSA签名；

**4、**发送给服务端，此时只有服务端（RSA私钥）能解密。

**5、**解密得到的随机数，再用AES加密，作为密钥（此时的密钥只有客户端和服务端知道）。



### 讲一下三次握手和四次挥手全过程

三次握手的过程给面试官甩一张图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoYnryQ9Kc2y05brZXs3oT6X6OSEPrbr4EVuWPFXko7Pe07BXNBhsBKnrz4HUoFbmJqKmue7GLnlg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

四次挥手的过程再给面试官甩一张图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoYnryQ9Kc2y05brZXs3oT6EiaSyiajIIACBlG1q6Je5zShAjGp9tsAD28aOSN0LXZ8dH18cRuia56FQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)




### 三次握手与四次挥手

**(1). 三次握手（我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功）**

- 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
- 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
- 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

**(2). 四次挥手（我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧）：**

- 第一次挥手：Client发送一个FIN，**用来关闭Client到Server的数据传送**，Client进入FIN_WAIT_1状态。
- 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
- 第三次挥手：Server发送一个FIN，**用来关闭Server到Client的数据传送**，Server进入LAST_ACK状态。
- 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。



### 为什么 TCP 链接需要三次握手，两次不可以么？

“三次握手” 的目的是为了防止**已失效的链接请求报文突然又传送到了服务端**，因而产生错误。

- 正常的情况：A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接。A 共发送了两个连接请求报文段，其中第一个丢失，第二个到达了 B。没有 “已失效的连接请求报文段”。
- 现假定出现了一种异常情况：即 A 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 B。本来这是一个早已失效的报文段。但 B 收到此失效的连接请求报文段后，就误认为是 A 再次发出的一个新的连接请求。于是就向 A 发出确认报文段，同意建立连接。

假设不采用“三次握手”，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向 B 发送数据。但 B 却以为新的运输连接已经建立，并一直等待 A 发来数据。这样，B 的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。

---



- 两次握手只能保证单向连接是畅通的

第一步，客户端给服务端发送一条消息：你好，服务端。第二步，服务端收到消息，同时给客户端回复一条消息：收到！你好客户端。

这样的两次握手过程， 客户端给服务端打招呼，服务端收到了，说明客户端可以正常给服务端发送数据。但是服务端给客户端打招呼，服务端没有收到反馈，也就不能确保服务端是否能正常给客户端发送消息。

- 只有经过第三次握手，才能确保双向都可以接收到对方的发送的数据 第三步，客户端收到服务端发送的消息，回复：收到！这样就证明了客户端能正常收到服务端的消息。



### 用现实理解三次握手的具体细节

三次握手的目的是建立可靠的通信信道，主要的目的就是双方确认自己与对方的发送与接收机能正常。

**1、**第一次握手：客户什么都不能确认；服务器确认了对方发送正常

**2、**第二次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己接收正常，对方发送正常

**3、**第三次握手：客户确认了：自己发送、接收正常，对方发送、接收正常；服务器确认 了：自己发送、接收正常，对方发送接收正常 所以三次握手就能确认双发收发功能都正常，缺一不可。



### 建立连接可以两次握手吗？为什么?

不可以。

因为可能会出现已失效的连接请求报文段又传到了服务器端。 > client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。

而且，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。





### 为什么要四次挥手？

TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当 A 向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据；B 向 A 发出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。

所以想要愉快的结束这次对话就需要四次挥手。



### IP地址是怎样分类的，你知道吗？

先说一下 IP 的基本特点：

- IP地址由四段组成，每个字段是一个字节，8位，最大值是255。
- IP地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。

IP 地址主要分为A、B、C三类及特殊地址D、E这五类，甩一张图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoYnryQ9Kc2y05brZXs3oT6scLHLEM9CZL3mH3PLdibXbSxo6f5MatN9yNjwYrsf4xmwzdKtsfK8sw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

**A类：** (1.0.0.0-126.0.0.0)一般用于大型网络。

**B类：** (128.0.0.0-191.255.0.0)一般用于中等规模网络。

**C类：** (192.0.0.0-223.255.255.0)一般用于小型网络。

**D类：** 是多播地址，地址的网络号取值于224~239之间，一般用于多路广播用户。

**E类：** 是保留地址。地址的网络号取值于240~255之间。



### TCP 协议如何来保证传输的可靠性

TCP 提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用 TCP 的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个 TCP 连接。在一个 TCP 连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过 TCP 链接交换 8 bit 字节构成的字节流，TCP 不在字节流中插入记录标识符。

**对于可靠性，TCP通过以下方式进行保证：**

- **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
- **对失序数据包重排序**：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
- **丢弃重复数据**：对于重复数据，能够丢弃重复数据；
- **应答机制**：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
- **超时重发**：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
- **流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。



### 客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？

服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认

**(1). DDos 攻击：**

- 客户端向服务端发送请求链接数据包
- 服务端向客户端发送确认数据包
- 客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认

**(2). DDos 预防：（没有彻底根治的办法，除非不使用TCP）**

- 限制同时打开SYN半链接的数目
- 缩短SYN半链接的Time out 时间
- 关闭不必要的服务



### GET 与 POST 的区别？

GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：

**1、** 从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；

**2、**从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；

**3、**从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。

**4、**就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。

**5、**从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。



### 为什么在GET请求中会对URL进行编码？ 

我们知道，在GET请求中会对URL中非西文字符进行编码，这样做的目的就是为了 **避免歧义**。看下面的例子，

针对 “name1=value1&name2=value2” 的例子，我们来谈一下数据从客户端到服务端的解析过程。首先，上述字符串在计算机中用ASCII吗表示为：

```
   6E616D6531 3D 76616C756531 26 6E616D6532 3D 76616C756532   6E616D6531：name1   3D：=    76616C756531：value1   26：&   6E616D6532：name2   3D：=    76616C756532：value2复制代码
```

服务端在接收到该数据后就可以遍历该字节流，一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再往后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。

现在考虑这样一个问题，如果我们的参数值中就包含=或&这种特殊字符的时候该怎么办？比如，“name1=value1”，其中value1的值是“va&lu=e1”字符串，那么实际在传输过程中就会变成这样“name1=va&lu=e1”。这样，我们的本意是只有一个键值对，但是服务端却会解析成两个键值对，这样就产生了歧义。

那么，如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码：例如，我们对上述会产生歧义的字符进行URL编码后结果：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。



### TCP与UDP的区别

TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：

- TCP是面向连接的，UDP是无连接的；
- TCP是可靠的，UDP是不可靠的；
- TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
- TCP是面向字节流的，UDP是面向报文的；
- TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；
- TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；



### TCP和UDP分别对应的常见应用层协议

**1、 TCP 对应的应用层协议：**

- **FTP**：定义了文件传输协议，使用21端口。常说某某计算机开了FTP服务便是启动了文件传输服务。下载文件，上传主页，都要用到FTP服务。
- **Telnet**：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于DOS模式下的通信服务。如以前的BBS是-纯字符界面的，支持BBS的服务器将23端口打开，对外提供服务。
- **SMTP**：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么SMTP端口设置这个栏，服务器开放的是25号端口。
- **POP3**：它是和SMTP对应，POP3用于接收邮件。通常情况下，POP3协议所用的是110端口。也是说，只要你有相应的使用POP3协议的程序（例如Fo-xmail或Outlook），就可以不以Web方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。
- **HTTP**：从Web服务器传输超文本到本地浏览器的传送协议。

**2、 UDP 对应的应用层协议：**

- **DNS**：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
- **SNMP**：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
- **TFTP(Trival File Transfer Protocal)**：简单文件传输协议，该协议在熟知端口69上使用UDP服务



### DNS的寻址过程你知道吗？

**（1）** 在浏览器中输入`www.baidu.com`域名，操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有就先调用这个IP地址映射，完成域名解析。

**（2）** 如果 hosts 里没有这个域名的映射，则查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有直接返回，完成域名解析。

**（3）** 如果 hosts 与本地 DNS 解析器缓存都没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。

**（4）** 如果要查询的域名，不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。

**（5）** 如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地 DNS 就把请求发至13台根 DNS ，根 DNS 服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地 DNS 服务器收到IP信息后，将会联系负责 .com 域的这台服务器。这台负责 .com 域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(baidu.com)给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 baidu.com 域服务器，重复上面的动作，进行查询，直至找到 www.baidu.com 主机。

**（6）** 如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不管是本地 DNS 服务器用是是转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。





### TCP 的拥塞避免机制

拥塞：对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。

拥塞控制：防止过多的数据注入到网络中，使得网络中的路由器或链路不致过载。

拥塞控制的方法：.

**1、 慢启动 + 拥塞避免：**

**慢启动**：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;



**拥塞避免**：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。



**2、快重传 + 快恢复：**

**快重传**：快重传要求接收方在收到一个 **失序的报文段** 后就立即发出 **重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。



**快恢复**：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。



### 什么是Socket

**1、**网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个Socket。Socket通常用来实现客户方和服务方的连接。Socket是TCP/IP协议的一个十分流行的编程界面，一个Socket由一个IP地址和一个端口号唯一确定。

**2、**但是，Socket所支持的协议种类也不光TCP/IP、UDP，因此两者之间是没有必然联系的。在Java环境下，Socket编程主要是指基于TCP/IP协议的网络编程。

**3、**socket连接就是所谓的长连接，客户端和服务器需要互相连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉的，但是有时候网络波动还是有可能的

**4、**Socket偏向于底层。一般很少直接使用Socket来编程，框架底层使用Socket比较多，



### Socket属于网络的那个层面

![](https://gitee.com/gsjqwyl/images_repo/raw/master/2021-3-11/20210325212441.png)

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个外观模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。



### Socket通讯的过程

**基于TCP：**

服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。

**基于UDP：**

UDP 协议是用户数据报协议的简称，也用于网络数据的传输。虽然 UDP 协议是一种不太可靠的协议，但有时在需要较快地接收数据并且可以忍受较小错误的情况下，UDP 就会表现出更大的优势。我客户端只需要发送，服务端能不能接收的到我不管



### Socket和http的区别和应用场景

**1、**Socket连接就是所谓的长连接，理论上客户端和服务器端一旦建立起连接将不会主动断掉；

**2、**Socket适用场景：网络游戏，银行持续交互，直播，在线视屏等。

**3、**http连接就是所谓的短连接，即客户端向服务器端发送一次请求，服务器端响应后连接即会断开等待下次连接

**4、**http适用场景：公司OA服务，互联网服务，电商，办公，网站等等等等




### 一次完整的HTTP请求所经历几个步骤?

HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：

**1、**建立TCP连接

怎么建立连接的，看上面的三次握手

**2、**Web浏览器向Web服务器发送请求行

一旦建立了TCP连接，**Web浏览器就会向Web服务器发送请求命令**。例如：GET /sample/hello.jsp HTTP/1.1。

**3、**Web浏览器发送请求头

浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，**之后浏览器发送了一空白行来通知服务器**，它已经结束了该头信息的发送。

**4、**Web服务器应答

客户机向服务器发出请求后，服务器会客户机回送应答， **HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。**

**5、**Web服务器发送应答头

正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

**6、**Web服务器向浏览器发送数据

Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，**它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据**。

**7、**Web服务器关闭TCP连接






### 浏览器中输入：“`www.xxx.com`” 之后都发生了什么？请详细阐述。

解析：经典的网络协议问题。

**1、**由域名→IP地址 寻找IP地址的过程依次经过了浏览器缓存、系统缓存、hosts文件、路由器缓存、 递归搜索根域名服务器。

**2、**建立TCP/IP连接（三次握手具体过程）

**3、**由浏览器发送一个HTTP请求

**4、**经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器

**5、**服务器处理该HTTP请求，返回一个HTML文件

**6、**浏览器解析该HTML文件，并且显示在浏览器端

**7、**这里需要注意：

- HTTP协议是一种基于TCP/IP的应用层协议，进行HTTP数据请求必须先建立TCP/IP连接
- 可以这样理解：HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。
- 两个计算机之间的交流无非是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。



### 什么是 HTTP 协议无状态协议？怎么解决Http协议无状态协议?

HTTP 是一个无状态的协议，也就是没有记忆力，这意味着每一次的请求都是独立的，缺少状态意味着如果后续处理需要前面的信息，则它必须要重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就很快。

HTTP 的这种特性有优点也有缺点：

- **优点**：解放了服务器，每一次的请求“点到为止”，不会造成不必要的连接占用
- **缺点**：每次请求会传输大量重复的内容信息，并且，在请求之间无法实现数据的共享

解决方案：

1. 使用参数传递机制：
   将参数拼接在请求的 URL 后面，实现数据的传递（GET方式），例如：`/param/list?username=wmyskxz`
   **问题**：可以解决数据共享的问题，但是这种方式一不安全，二数据允许传输量只有1kb
2. 使用 Cookie 技术
3. 使用 Session 技术



### Session、Cookie 与 Application

Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。

**1、Cookie 及其相关 API ：**

Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。 



**2、Session 及其相关 API：**

同样地，会话状态也可以保存在服务器端。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用 **cookie机制** ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 **URL重写机制**将sessionid传回服务器。



**3、 Session 与 Cookie 的对比：**

- **实现机制**：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；
- **大小限制**：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；
- **安全性**：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；
- **服务器资源消耗**：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。



**4、Application：**

Application（ServletContext）：与一个Web应用程序相对应，为应用程序提供了一个全局的状态，所有客户都可以使用该状态。



### 有哪些 web 性能优化技术?

- DNS查询优化
- 客户端缓存
- 优化TCP连接
- 避免重定向
- 网络边缘的缓存
- 条件缓存
- 压缩和代码极简化
- 图片优化



### 什么是 XSS 攻击？

**XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击**。XSS的重点不在于跨站点，而在于脚本的执行。

XSS的原理是：

恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。

XSS攻击最主要有如下分类：`反射型`、`存储型`、及 `DOM-based型`。反射性和DOM-baseed型可以归类为`非持久性XSS攻击`。存储型可以归类为`持久性XSS攻击`。



### 什么是跨站攻击CSRF？

CSRF（Cross Site Request Forgery，跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一，也被称为『One Click Attack』或者 『Session Riding』，通常缩写为`CSRF`或者`XSRF`，是一种对网站的恶意利用。

听起来像跨站脚本（XSS），但它与XSS非常不同，并且攻击方式几乎相左。

XSS利用站点内的信任用户，而CSRF则通过伪装来自受信任用户的请求来利用受信任的网站。与XSS攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。





### 滑动窗口机制

由发送方和接收方在三次握手阶段，互相将自己的最大可接收的数据量告诉对方。

也就是自己的数据接收缓冲池的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知。这就实现了流量的控制。



### 常用的HTTP方法有哪些？

- **GET：**用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- **POST：**用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- **PUT：**传输文件，报文主体中包含文件内容，保存到对应URI位置。
- **HEAD：**获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- **DELETE：**删除文件，与PUT方法相反，删除对应URI位置的文件。
- **OPTIONS：**查询相应URI支持的HTTP方法。



### 常见HTTP状态码

**1、**1xx（临时响应）

**2、**2xx（成功）

**3、**3xx（重定向）：表示要完成请求需要进一步操作

**4、**4xx（错误）：表示请求可能出错，妨碍了服务器的处理

**5、**5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误



**常见状态码：**

- 200（成功）
- 304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容
- 401（未授权）：请求要求身份验证
- 403（禁止）：服务器拒绝请求
- 404（未找到）：服务器找不到请求的网页



### SQL 注入

SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

**1、SQL注入攻击的总体思路：**

1. 寻找到SQL注入的位置
2. 判断服务器类型和后台数据库类型
3. 针对不通的服务器和数据库特点进行SQL注入攻击

**2、SQL注入攻击实例：**

比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：

```
用户名： ‘or 1 = 1 --密 码：复制代码
```

用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：

```
String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”;
```

因此，当输入了上面的用户名和密码，上面的SQL语句变成：

```
SELECT * FROM user_table WHERE username=’’or 1 = 1 – and password=’’
```

分析上述SQL语句我们知道，username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。

**3、应对方法：**

1.参数绑定：

使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用#和

```
不能识别此Latex公式:来获取参数值。当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入；当使用复制代码
```

时，变量就是直接追加在sql中，一般会有sql注入问题。

2.使用正则表达式过滤传入的参数



### XSS 攻击

XSS是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。

**1、XSS攻击的危害：**

- 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号
- 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力
- 盗窃企业重要的具有商业价值的资料
- 非法转账
- 强制发送电子邮件
- 网站挂马
- 控制受害者机器向其它网站发起攻击

**2、原因解析：**

- **主要原因**：过于信任客户端提交的数据！
- **解决办法**：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。
- **进一步分析细节**：客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了，那么攻击者就可以肆无忌惮地展开攻击啦，因此我们绝不可以信任任何客户端提交的数据！！！

**3、XSS 攻击分类：**

- 1. 反射性 XSS 攻击（非持久性 XSS 攻击）：

漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS攻击包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)，例如，正常发送消息：

```
http://www.test.com/message.php?send=Hello,World！复制代码
```

接收者将会接收信息并显示Hello,World；但是，非正常发送消息：

```
http://www.test.com/message.php?send=<script>alert(‘foolish!’)</script>！复制代码
```

接收者接收消息显示的时候将会弹出警告窗口！

- 2. 持久性XSS攻击 (留言板场景)：

XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。与非持久性XSS攻击相比，持久性XSS攻击危害性更大。从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。

例如，留言板表单中的表单域：

```
<input type=“text” name=“content” value=“这里是用户填写的数据”>复制代码
```

正常操作流程是：用户是提交相应留言信息 —— 将数据存储到数据库 —— 其他用户访问留言板，应用去数据并显示；而非正常操作流程是攻击者在value填写:

```
<script>alert(‘foolish!’)；</script> <!--或者html其他标签（破坏样式）、一段攻击型代码-->复制代码
```

并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码。

**4、修复漏洞方针：**

漏洞产生的根本原因是 **太相信用户提交的数据，对用户所提交的数据过滤不足所导致的**，因此解决方案也应该从这个方面入手，具体方案包括：

- 将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了（如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击）；
- 表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。
- 对数据进行Html Encode 处理
- 过滤或移除特殊的Html标签，例如: `<script>`, `<iframe>` , `< for <`, `> for>`, `&quot for`
- 过滤JavaScript 事件的标签，例如 “onclick=”, “onfocus” 等等。

需要注意的是，在有些应用中是允许html标签出现的，甚至是javascript代码出现。因此，我们在过滤数据的时候需要仔细分析哪些数据是有特殊要求（例如输出需要html代码、javascript代码拼接、或者此表单直接允许使用等等），然后区别处理！



### OSI 网络体系结构与 TCP/IP 协议模型

OSI 是一个理论上的网络通信模型，而 TCP/IP 则是实际上的网络通信标准。但是，它们的初衷是一样的，都是为了使得两台计算机能够像两个知心朋友那样能够互相准确理解对方的意思并做出优雅的回应。现在，我们对 OSI 七层模型的各层进行简要的介绍：

**1、**物理层

参考模型的最低层，也是OSI模型的第一层，实现了相邻计算机节点之间比特流的透明传送，并尽可能地屏蔽掉具体传输介质和物理设备的差异，使其上层(数据链路层)不必关心网络的具体传输介质。

**2、**数据链路层（data link layer）

接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路，即提供可靠的通过物理介质传输数据的方法。

**3、**网络层

将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。

**4、**传输层（transport layer）

在源端与目的端之间提供可靠的透明数据传输，使上层服务用户不必关系通信子网的实现细节。在协议栈中，传输层位于网络层之上，传输层协议为不同主机上运行的进程提供逻辑通信，而网络层协议为不同主机提供逻辑通信，如下图所示。

实际上，网络层可以看作是传输层的一部分，其为传输层提供服务。但对于终端系统而言，网络层对它们而言是透明的，它们知道传输层的存在，也就是说，在逻辑上它们认为是传输层为它们提供了端对端的通信，这也是分层思想的妙处。

**5、**会话层（Session Layer）

会话层是OSI模型的第五层，是用户应用程序和网络之间的接口，负责在网络中的两节点之间建立、维持和终止通信。

**6、**表示层（Presentation Layer）：数据的编码，压缩和解压缩，数据的加密和解密

表示层是OSI模型的第六层，它对来自应用层的命令和数据进行解释，以确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。

**7、**应用层（Application layer）：为用户的应用进程提供网络通信服务



### 网络层的 ARP 协议工作原理？

地址解析协议(ARP) 是通过解析网路层地址来找寻数据链路层地址的一个在网络协议包中极其重要的网络传输协议。

**网络层的ARP协议完成了IP地址与物理地址的映射**。首先，每台主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己ARP列表中是否存在该IP地址对应的MAC地址：如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。



### IP地址的分类

整个的因特网就是一个单一的、抽象的网络。IP 地址就是给因特网上的每一个主机（或路由器）的每一个接口分配一个在全世界范围是唯一的 32 位标识符，它是一个逻辑地址，用以屏蔽掉物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。

每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：

- A类地址：以0开头，第一个字节范围：0~127；
- B类地址：以10开头，第一个字节范围：128~191；
- C类地址：以110开头，第一个字节范围：192~223；
- D类地址：以1110开头，第一个字节范围为224~239；
- E类地址：以1111开头，保留地址

**1、 A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是“0”**

一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。

A类IP地址的地址范围1.0.0.0到127.255.255.255（二进制表示为：00000001 00000000 00000000 00000000 - 01111110 11111111 11111111 11111111），最后一个是广播地址。A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台。

**2、B类地址: 2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是“10”**

一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。

B类IP地址地址范围128.0.0.0-191.255.255.255（二进制表示为：10000000 00000000 00000000 00000000—-10111111 11111111 11111111 11111111），最后一个是广播地址。B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。

**3、C类地址: 3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是“110”**

一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。

C类IP地址范围192.0.0.0-223.255.255.255（二进制表示为: 11000000 00000000 00000000 00000000 - 11011111 11111111 11111111 11111111）。C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台。

**4、D类地址:多播地址，用于1对多通信，最高位必须是“1110”**

　　D类IP地址在历史上被叫做多播地址(multicast address)，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。

**5、E类地址:为保留地址，最高位必须是“1111”**



### IP地址与物理地址

物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议用于IP地址与物理地址的对应。



### 影响网络传输的因素有哪些？

将一份数据从一个地方正确地传输到另一个地方所需要的时间我们称之为响应时间。影响这个响应时间的因素有很多。

**1、网络带宽：**

所谓带宽就是一条物理链路在 1s 内能够传输的最大比特数，注意这里是比特（bit）而不是字节数，也就是 b/s 。网络带宽肯定是影响数据传输的一个关键环节，因为在当前的网络环境中，平均网络带宽只有 1.7 MB/s 左右。

**2、传输距离：**

也就是数据在光纤中要走的距离，虽然光的传播速度很快，但也是有时间的，由于数据在光纤中的移动并不是走直线的，会有一个折射率，所以大概是光的 2/3，这个时间也就是我们通常所说的传输延时。传输延时是一个无法避免的问题，例如，你要给在杭州和青岛的两个机房的一个数据库进行同步数据操作，那么必定会存在约 30ms 的一个延时。

**3、TCP 拥塞控制：**

我们知道 TCP 传输是一个 “停-等-停-等” 的协议，传输方和接受方的步调要一致，要达到步调一致就要通过拥塞控制来调节。TCP 在传输时会设定一个 “窗口”，这个窗口的大小是由带宽和 RTT（Round-Trip Time，数据在两端的来回时间，也就是响应时间）决定的。计算的公式是带宽（b/s）xRTT（s）。通过这个值就可以得出理论上最优的 TCP 缓冲区的大小。Linux 2.4 已经可以自动地调整发送端的缓冲区的大小，而到 Linux 2.6.7 时接收端也可以自动调整了。



### 什么是对称加密与非对称加密

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方；

而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，非常的慢



### 你知道对称加密和非对称加密的区别和原理吗？

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即`如何安全地将密钥发给对方`;

而非对称加密是指使用一对非对称密钥，即`公钥`和`私钥`，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以`保证安全性`；但是和对称加密比起来，它比较`慢`，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。



### 什么是Cookie

cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器



### 什么是Session

session 是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。

服务器默认为客户浏览器的cookie中设置 sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie 包含 sessionid ，服务器根据传输cookie 中的 sessionid 获取出会话中存储的信息，然后确定会话的身份信息。



### Cookie和Session对于HTTP有什么用？

 HTTP协议本身是无法判断用户身份。所以需要cookie或者session



### Cookie与Session区别

**1、**Cookie数据存放在客户端上，安全性较差，Session数据放在服务器上，安全性相对更高

**2、**单个cookie保存的数据不能超过4K，session无此限制

**3、**session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当使用cookie。